# Intuition

ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ êµ¬ì¡°ë¥¼ ì‚¬ìš©í•˜ì—¬ 1ë²ˆ ë…¸ë“œë¶€í„° ì‹œì‘í•˜ì—¬ ê° ë…¸ë“œì™€ ì—°ê²°ëœ ë…¸ë“œë“¤ì„ ìˆœì°¨ì ìœ¼ë¡œ íƒìƒ‰í•œë‹¤.

# Approach

1. ì£¼ì–´ì§„ ê°„ì„  ì •ë³´ ë°°ì—´ì„ íƒìƒ‰í•˜ë©° ê° ë…¸ë“œë§ˆë‹¤ ì—°ê²°ëœ ë…¸ë“œë¥¼ ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¡œ êµ¬í•œë‹¤.
2. ì‹œì‘ë…¸ë“œì¸ 1ë²ˆ ë…¸ë“œì—ì„œ ë°©ë¬¸í•  ìˆ˜ ìˆëŠ” ë…¸ë“œë“¤ì„ queueì— ë‹´ëŠ”ë‹¤.
   2-1. ì´ë¯¸ ë°©ë¬¸í•œ ë…¸ë“œì— ì¤‘ë³µ ë°©ë¬¸ì„ ë°©ì§€í•˜ê¸° ìœ„í•´ queueì— ë…¸ë“œë¥¼ ë‹´ì„ ë•Œ visited ë°°ì—´ì„ ì‚¬ìš©í•˜ì—¬ ë°©ë¬¸ ì—¬ë¶€ë¥¼ ê¸°ë¡í•œë‹¤.
3. queueë¥¼ íƒìƒ‰í•˜ë©° í˜„ì¬ queueì— ë‹´ê¸´ ë…¸ë“œë“¤ê³¼ ì—°ê²°ë˜ì–´ ìˆìœ¼ë©°(= ë°©ë¬¸ ê°€ëŠ¥ ì—¬ë¶€) visitedê°€ falseì¸ ë…¸ë“œë“¤ì„ ì„ì‹œ ë°°ì—´ì— ì €ì¥í•œë‹¤. í˜„ì¬ queueì— ë‹´ê¸´ ë…¸ë“œë“¤ì€ 1ë²ˆ ë…¸ë“œì—ì„œ ë™ì¼í•œ ê²½ë¡œë§Œí¼ ë–¨ì–´ì§„ ë…¸ë“œë“¤ì´ë‹¤.
   4-1.í•´ë‹¹ ì°¨ìˆ˜ì—ì„œ ë°©ë¬¸í•  ìˆ˜ ìˆëŠ” ëª¨ë“  ë…¸ë“œë“¤ì„ ì„ì‹œ ë°°ì—´ì— ì €ì¥ í›„ ê·¸ ê¸¸ì´ê°€ 0ì´ ì•„ë‹Œ ê²½ìš°, ì•„ì§ ë°©ë¬¸ ê°€ëŠ¥ ë…¸ë“œê°€ ìˆìœ¼ë¯€ë¡œ queueë¥¼ ì„ì‹œ ë°°ì—´ë¡œ ì´ˆê¸°í™” í›„ ë‹¤ìŒ ì°¨ìˆ˜ì˜ ë…¸ë“œë“¤ì„ ë‹¤ì‹œ ìˆœíšŒí•œë‹¤.
   4-2. í•´ë‹¹ ì°¨ìˆ˜ì—ì„œ ë°©ë¬¸í•  ìˆ˜ ìˆëŠ” ëª¨ë“  ë…¸ë“œë“¤ì„ ì„ì‹œ ë°°ì—´ì— ì €ì¥ í›„ ê·¸ ê¸¸ì´ê°€ 0ì¸ ê²½ìš°, 1ê³¼ ê°€ì¥ ë©€ë¦¬ ë–¨ì–´ì§„ ë…¸ë“œì— ë„ë‹¬í–ˆìœ¼ë©° ë” ì´ìƒ ë°©ë¬¸ ê°€ëŠ¥í•œ ë…¸ë“œê°€ ì—†ëŠ” ê²ƒì´ë‹¤. í˜„ì¬ queueì— ì €ì¥ëœ ë…¸ë“œë“¤ì´ ê°€ì¥ ë©€ë¦¬ ë–¨ì–´ì§„ ë…¸ë“œë“¤ì´ë¯€ë¡œ í˜„ì¬ queue.lengthë¥¼ ë°˜í™˜í•œë‹¤.

# Complexity

TC : ğ‘‚(ğ‘‰+ğ¸)
SC : O(V+E)

# Code

```
function solution(n, edge) {
    const board = {};
    for(let [v1,v2] of edge){
        if(!board[v1]) board[v1] = [];
        if(!board[v2]) board[v2] = [];
        board[v1].push(v2);
        board[v2].push(v1);

    }
    let visited = Array.from({length : n + 1} , ()=>false);
    visited[1] = true
    let queue = board["1"]
    board["1"].forEach((vertex)=>{visited[vertex] = true;});

    while(queue.length){
        let tempQueue = [];
        for(let i = 0 ;i<queue.length; i++){
            const v = queue[i];
            board[v].forEach((vertex)=>{
               if(!visited[vertex]){
                   visited[vertex] = true;
                   tempQueue.push(vertex);
               }
           });
        }
        if(!tempQueue.length) return queue.length
        queue = tempQueue
    }
}
```

```
//Case2. ê°€ë…ì„± ê°œì„ 


function solution(n, edge) {
    //ê°ì²´ ëŒ€ì‹  ë°°ì—´ì„ ì‚¬ìš©í•˜ì—¬ ì½”ë“œ ê°€ë…ì„±ì„ ìƒìŠ¹ì‹œí‚¤ê³  ì ‘ê·¼ ì†ë„ í–¥ìƒ
    const board = Array.from({length : n + 1} , ()=>[]);
    const visited = Array.from({length : n + 1} , ()=>false);

    for(let [v1,v2] of edge){
        board[v1].push(v2);
        board[v2].push(v1);
    }
    //queueì— 1ì˜ ì¸ì ‘ë¦¬ìŠ¤íŠ¸ ëŒ€ì‹  1ì—ì„œ ë¶€í„° ì‹œì‘í•˜ì—¬ ë¶ˆí•„ìš”í•œ ì½”ë“œ ê°œì„ 
    visited[1] = true;
    let queue = [1];

    while(queue.length){
        let tempQueue = [];
        const levelSize = queue.length;

        for(let i = 0 ;i<levelSize; i++){
            const node = queue.shift();
            board[node].forEach((v)=>{
               if(!visited[v]){
                   visited[v] = true;
                   queue.push(v);
               }
           });
        }
        if(!queue.length) return levelSize;
    }
}
```
